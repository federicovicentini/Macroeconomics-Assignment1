---
title: "Macroeconomics - Assignment no.1"
author: "Federico Vicentini , Riccardo Dal Cero, Xhesjana Shametaj, Alice Pratesi"
date: "27/5/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Initial Operations

```{r p0, message=FALSE}

# Clear the variables
rm(list = ls())

# Set the working directory to source file location with
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))

# Install packages
packages <- c("tidyverse", "rsdmx", "eurostat", "tbl2xts", 
              "tidyquant", "BCDating", "pwt10", "dplyr")
new.packages <- packages[!(packages %in% installed.packages()[, "Package"])]
if (length(new.packages)) install.packages(new.packages)
invisible(lapply(packages, library, character.only = TRUE))

# Load packages
library(quantmod)
library(eurostat)

```

## POINT 1

First of all, we need to get the data USA and we needed from the Fred database, using a for cycle and the function \textttt{getSymbols()}

```{r p1}

nipa <- c("EXPGS", "IMPGS", "PCEC", "GDP", "GPDI", "GCE")
for (i in 1:length(nipa)) {
  getSymbols(nipa[i], src = "FRED")
}

```

After that we get residuals from NIPA equation (using function "res") to proe that y = sum of their components and we plot them 
```{r p1.2}
res=((EXPGS - IMPGS + PCEC + GPDI + GCE) - GDP)^2
plot(res)
```

Now we check the same identity of other two countries from Eurostat Database (we chose Spain and France). 
Firstly we get Eurostat data listing
```{r p1.3}
toc <- get_eurostat_toc()
```

Then we install new packages and a very simple table with the function "kable"
```{r p1.4}
library(knitr)
kable(tail(toc))

library(xts)
library(ecb)
```


```{r p1.4.1, message = FALSE}
# For the original data, see
# http://ec.europa.eu/eurostat/tgm/table.do?tab=table&init=1&plugin=1&language=en&pcode=tsdtr210
```

Secondly, we import the data of GDP from the Eurostat 
```{r p1.5}

namq_10_gdp <- get_eurostat("namq_10_gdp",
  stringsAsFactors = FALSE)
```


Subsequently we create new vectors for list of the two countries selected, for NIMA aggregates (Investment, Consumption, Import, Export, Public Spending) 
```{r p1.6}

nimacountries <- c("ES", "FR")

nimaeu <- c("B1GQ", "P31_S14_S15", "P3_S13", "P51G", "P52", "P53", "P6", "P7")

```

Obviously we need to create a matrix dataeu to fill with data from the two countries and we transform the name for columns in the matrix dataeu. At the end we decide to set Z to partition columns (we obtain 8 partition)
```{r p1.7}

colname <- c( "GDP", "C", "G", "I", "inv", "saldo", "X", "IM",
  "GDPb", "Cb", "Gb", "Ib", "invb", "saldob", "Xb", "IMb")

dataeu <- matrix(NA, 89, length(nimacountries) * length(nimaeu))
colnames(dataeu) <- colname

z <- length(colname) / length(nimacountries)
```

Finally, we arrive to use the function "for" cycle to fill dataeu with data from the two countries and we filter for some variables
```{r p1.8}
for (i in 1:length(nimacountries)) {
  for (s in 1:length(nimaeu)) {
    newdata <- namq_10_gdp %>%
      filter(geo == nimacountries[i]) %>%
      filter(time >= "2000-01-01") %>%
      filter(unit == "CP_MEUR") %>%
      filter(s_adj == "SCA") %>%
      filter(na_item == nimaeu[s])
    newdata$time <- convert_dates(newdata$time)
    newdataxts <- xts(newdata$values, newdata$time)
    dataeu[, (s + (z * (i - 1)))] <- newdataxts
  }
}
```

Before we check the identity of NIMA for the countries, we first change import from + to - in both to simplify the eqaution and we convert dataeu to xts format
```{r p1.8.1}
dataeu[, z] <- dataeu[, z] * (-1)
dataeu[, length(colname)] <- dataeu[, length(colname)] * (-1)

dataeu <- xts(dataeu, rev(newdata$time))
```

At the end we can finally check the NIMA identity for the Country 1 (Spain) in this way:
- we create an empty vestors for sums of aggregates and fro GDP
- We fill them with the data using a for cycle 
- We print the value and plot the graphs of SUM and GDP

```{r p1.9}

sums <- c()
gdp <- c()

for (i in 1:nrow(dataeu)) {
  sums[i] <- sum(dataeu[i, -c(1, (z + 1):length(colname))])
  gdp[i] <- dataeu[i, 1]
}

sum(dataeu[i, -c(1, z:length(colname))]) - dataeu[i, z]
dataeu[, -c(1, z:length(colname))]

plot(sums, col = "green", type = "l")
lines(gdp, col = "red", type = "l")
plot(sums - gdp)
```

To check the identity for the second country (France), the code is almost the same
```{r p1.20}
sums2 <- c()
gdp2 <- c()
for (i in 1:nrow(dataeu)) {
  sums2[i] <- sum(dataeu[i, -c(1:(z + 1))])
  gdp2[i] <- dataeu[i, (z + 1)]
}

sum(dataeu[1, -c(1:(z + 1))]) - dataeu[1, length(colname)]

dataeu[i, (z + 1)]

dataeu[1, -c(1:(z + 1), length(colname))]

plot(sums2, col = "green", type = "l")
lines(gdp2, col = "red", type = "l")
plot(sums2 - gdp2)
```


## POINT 2

First of all, we import the library BCDating and we generate a matrix to fill with the log of the variables (we takes the log level to transform data)

```{r p2}
library(BCDating)

data_bc <- matrix(NA, length(GDP), 4)

data_bc[, 1] <- log(GDP)
data_bc[, 2] <- log(IMPGS)
data_bc[, 3] <- log(GPDI)
data_bc[, 4] <- log(PCEC)
```

After that, we create a time series (using for cycle) with the variables[count] and setting the time index as year-quarter
```{r p2.1}
for (count in 1:4) {
  data_ts <- ts(data_bc[, count], start = c(1947, 1), frequency = 4)

# Then we apply the BBQ methods (Bayesian Binning into Quantiles)  to obtain a well-calibrated confidence estimate and we plot the results 
  bc_US <- BBQ(data_ts, name = count)
 
  summary(bc_US)
  plot(bc_US, data_ts)
}

```

As you can see, for the fisrt variable (GDP) we have long phases of Expansion (ex.202) and nowadays we are in a phase of Expansion.
For the Imports we can see more phases 
