---
title: "Macroeconomics - Assignment no.1"
author: "Federico Vicentini , Riccardo Dal Cero, Xhesjana Shametaj, Alice Pratesi"
date: "27/5/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Initial Operations

```{r p0, message=FALSE}


#################
##### POINT 1####
#################

# Clear the variables
rm(list = ls())

# Set the working directory to source file location with
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))

# Install packages
packages <- c("tidyverse", "rsdmx", "eurostat", "tbl2xts", 
              "tidyquant", "BCDating", "pwt10", "dplyr")
new.packages <- packages[!(packages %in% installed.packages()[, "Package"])]
if (length(new.packages)) install.packages(new.packages)
invisible(lapply(packages, library, character.only = TRUE))

# Load packages
library(quantmod)
library(eurostat)

```

## POINT 1

First of all, we need to get the data of USA we needed from the Fred database, using a for cycle and the function \textttt{getSymbols()}

```{r p1}

nipa <- c("EXPGS", "IMPGS", "PCEC", "GDP", "GPDI", "GCE")
for (i in 1:length(nipa)) {
  getSymbols(nipa[i], src = "FRED")
}

# Get residuals from NIPA equation and then plot them
res=((EXPGS - IMPGS + PCEC + GPDI + GCE) - GDP)^2
plot(res)


# GET THE OTHER TWO COUNTRIES FROM EUROSTAT DATABASE

# Get Eurostat data listing
toc <- get_eurostat_toc()

# Check the first items
library(knitr)
kable(tail(toc))

library(xts)
library(ecb)

# For the original data, see
# http://ec.europa.eu/eurostat/tgm/table.do?tab=table&init=1&plugin=1&language=en&pcode=tsdtr210

# GDP download
namq_10_gdp <- get_eurostat("namq_10_gdp",
  stringsAsFactors = FALSE
)

# Create vector with list of countries
nimacountries <- c("ES", "FR")

# Create a vector with codes for NIMA aggregates
nimaeu <- c("B1GQ", "P31_S14_S15", "P3_S13", "P51G", "P52", "P53", "P6", "P7")

# Create a vector with names for columns in matrix dataeu
colname <- c(
  "GDP", "C", "G", "I", "inv", "saldo", "X", "IM",
  "GDPb", "Cb", "Gb", "Ib", "invb", "saldob", "Xb", "IMb"
)

# Create matrix dataeu to fill with data from the 2 countries
dataeu <- matrix(NA, 89, length(nimacountries) * length(nimaeu))
colnames(dataeu) <- colname

# Set z to partition columns
z <- length(colname) / length(nimacountries)

# For cycle to fill dataeu with data from the countries
for (i in 1:length(nimacountries)) {
  for (s in 1:length(nimaeu)) {
    newdata <- namq_10_gdp %>%
      filter(geo == nimacountries[i]) %>%
      filter(time >= "2000-01-01") %>%
      filter(unit == "CP_MEUR") %>%
      filter(s_adj == "SCA") %>%
      filter(na_item == nimaeu[s])
    newdata$time <- convert_dates(newdata$time)
    newdataxts <- xts(newdata$values, newdata$time)
    dataeu[, (s + (z * (i - 1)))] <- newdataxts
  }
}

# Change Imports from positive to negative in both countries
dataeu[, z] <- dataeu[, z] * (-1)
dataeu[, length(colname)] <- dataeu[, length(colname)] * (-1)

# Convert dataeu to xts format
dataeu <- xts(dataeu, rev(newdata$time))

# Check NIMA identity for country 1

#Create empty vectors for sums of aggregates and for gdp
sums <- c()
gdp <- c()
#Fill them with the data using a for cycle
for (i in 1:nrow(dataeu)) {
  sums[i] <- sum(dataeu[i, -c(1, (z + 1):length(colname))])
  gdp[i] <- dataeu[i, 1]
}

#Plot the values
sum(dataeu[i, -c(1, z:length(colname))]) - dataeu[i, z]
dataeu[, -c(1, z:length(colname))]

#Plot the graphs
plot(sums, col = "green", type = "l")
lines(gdp, col = "red", type = "l")
plot(sums - gdp)


# Check NIMA identity for country 2
# Code is the same as before

sums2 <- c()
gdp2 <- c()
for (i in 1:nrow(dataeu)) {
  sums2[i] <- sum(dataeu[i, -c(1:(z + 1))])
  gdp2[i] <- dataeu[i, (z + 1)]
}

sum(dataeu[1, -c(1:(z + 1))]) - dataeu[1, length(colname)]

dataeu[i, (z + 1)]

dataeu[1, -c(1:(z + 1), length(colname))]

plot(sums2, col = "green", type = "l")
lines(gdp2, col = "red", type = "l")
plot(sums2 - gdp2)









#################
##### POINT 2####
#################

#Import the library
library(BCDating)

# Generate a matrix to fill with the log of the variables
data_bc <- matrix(NA, length(GDP), 4)

# Yaking logs
data_bc[, 1] <- log(GDP)
data_bc[, 2] <- log(IMPGS)
data_bc[, 3] <- log(GPDI)
data_bc[, 4] <- log(PCEC)

for (count in 1:4) {
  # create a time series with the variable[count]
  # setting the time index as year-quarter
  data_ts <- ts(data_bc[, count], start = c(1947, 1), frequency = 4)
  # applied the BBQ method
  bc_US <- BBQ(data_ts, name = count)
  # plot the results
  summary(bc_US)
  plot(bc_US, data_ts)
}
```

<<<<<<< HEAD
As you can see, for the first variable (GDP) we have long phases of Expansion (ex.202) and nowadays we are in a phase of Expansion.
For the Imports we can see more phases and at the end of the 2020 started a new Expansion 
Fort the Investment (GDPI) there are a lot oh phases (41) and we can see that the longer Expansions are between 1960-1966 and between 2009-2015.
At the end for the Consumption, we can see that between 2009 and 2019 there was a very long phase of Expansion 

To sum up 


## POINT 4

First of all, we need to download the aggregate data from the website of the book "Applied Macroeconomics" by Favero and we delete the ID column since it is unuseless for our purpose
```{r p4.1}
favero <- read.csv("MRW.csv", sep = ";", dec = ",")

favero$ID <- NULL
```

Now we can create a dataframe with only the variables we are interested in: YL85 that is the GDP per working age person il 1985, N6085 that is the rate of growth of population and IY that is investment on GDP (we also change the name)
```{r p4.2}
replica <- data.frame(favero$YL85, favero$N6085, favero$IY)
names(replica) <- c("Ypc", "PopGrowth", "IonY")
```

To replicate the results of Favero, we need to transform our variables into logarithms and we add g+delta to n.
Since the equation is: log(Y/L) = a + (alfa/1+alfa)*ln(s) - (alfa/1-alfa)*ln(n+g+delta)
Where "s" is the 
```{r p4.3}
replica$Ypc <- log(replica$Ypc)
replica$PopGrowth <- log(((replica$PopGrowth) / 100) + 0.05)
replica$IonY <- log((replica$IonY) / 100)
names(replica)[2] <- "ngdelta"
```

#Replicate regression results
reg <- lm(Ypc ~ IonY + ngdelta, data = replica)

#Print them using stargazer function
library(stargazer)
stargazer(reg, type = "text")



#Do hypothesis testing with the two provided restrictions 
#(which were respectively b1=-b2 ; b1=0.5 & b2=-0.5)

library(car)
linearHypothesis(reg, c("IonY-ngdelta=0"), test = "F")
linearHypothesis(reg, c("IonY=0.5", "ngdelta=-0.5"), test = "F")



#Perform bootstrapping using Boot from the package car

Boot(reg)


#Load library boot

library(boot)

#Create bs function to get coefficients from the regression

bs = function(formula, data, indices){
  d = data[indices,]
  fit=lm(formula, data=d)
  return(coef(fit))
}

#Create var results with function boot on the regression

results = boot(replica, statistic=bs, R=1000, formula= Ypc ~ IonY + ngdelta)

#Print the results

results



#Add schooling the replica database

replica$school=log((favero$SCHOOL)/100)



#Replicate the augmented Solow model

reg2 = lm(Ypc ~ IonY + ngdelta + school, data = replica)

#Print results using the Stargazer function

stargazer(reg2, type = "text")


=======
>>>>>>> 6510429d8d06c2387f0dda922fa05e0e06febb49
<<<<<<< HEAD
=======

>>>>>>> 2eeb16f80fc78d7cbfadaefbdb0bac424c6e4617
